**目录：**
- [5. 基本引用类型](#5-基本引用类型)
  - [5.1. Date](#51-date)
    - [5.1.1. 继承的方法](#511-继承的方法)
    - [5.1.2. 日期格式化方法](#512-日期格式化方法)
    - [5.1.3. 日期/时间组件方法](#513-日期时间组件方法)
  - [5.2. RegExp](#52-regexp)
    - [5.2.1. RegExp 实例属性](#521-regexp-实例属性)
    - [5.2.2. RegExp 实例方法](#522-regexp-实例方法)
    - [5.2.3. RegExp 构造函数属性](#523-regexp-构造函数属性)
    - [5.2.4. 模式局限](#524-模式局限)
  - [5.3. 原始值包装类型](#53-原始值包装类型)
    - [5.3.1. Boolean](#531-boolean)
    - [5.3.2. Number](#532-number)
    - [5.3.3. String](#533-string)

# 5. 基本引用类型

本章内容

- 理解对象
- 基本 JavaScript 数据类型
- 原始值与原始值包装类型

引用值（或者对象）是某个特定引用类型的实例。在 ECMAScript 中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”。虽然从技术上讲 JavaScript 是一门面向对象语言，但 ECMAScript 缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。

注意 引用类型虽然有点像类，但跟类并不是一个概念。为避免混淆，本章后面不会使用术语“类”。

对象被认为是某个特定引用类型的实例。新对象通过使用 new 操作符后跟一个 **构造函数(constructor)** 来创建。构造函数就是用来创建新对象的函数，比如下面这行代码：

```js
let now = new Date();
```

这行代码创建了引用类型 Date 的一个新实例，并将它保存在变量 now 中。Date()在这里就是构造函数，它负责创建一个只有默认属性和方法的简单对象。ECMAScript 提供了很多像 Date 这样的原生引用类型，帮助开发者实现常见的任务。

注意 函数也是一种引用类型，但有关函数的内容太多了，一章放不下，所以本书专门用第 10 章来介绍函数。

## 5.1. Date

ECMAScript 的 Date 类型参考了 Java 早期版本中的 java.util.Date。为此，Date 类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间 1970 年 1 月 1 日午夜（零时）至今所经过的毫秒数。使用这种存储格式，Date 类型可以精确表示 1970 年 1 月 1 日之前及之后 285 616 年的日期。

要创建日期对象，就使用 new 操作符来调用 Date 构造函数：

```js
let now = new Date();
```

在不给 Date 构造函数传参数的情况下，创建的对象将保存当前日期和时间。要基于其他日期和时间创建日期对象，必须传入其毫秒表示（UNIX 纪元 1970 年 1 月 1 日午夜之后的毫秒数）。ECMAScript 为此提供了两个辅助方法：Date.parse()和 Date.UTC()。

Date.parse()方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。ECMA-262 第 5 版定义了 Date.parse()应该支持的日期格式，填充了第 3 版遗留的空白。所有实现都必须支持下列日期格式：

- “月/日/年”，如"08/07/2021"；
- “月名 日, 年”，如"Aug 07, 2021"；
- “周几 月名 日 年 时:分:秒 时区”，如"Sat Aug 07 2021 00:00:00 GMT-0700"；
- ISO 8601 扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如 2021-08-07T00:00:00（只适用于
  兼容 ES5 的实现）。

比如，要创建一个表示“2021 年 08 月 07 日”的日期对象，可以使用以下代码：

```js
let someDate = new Date(Date.parse("Aug 07, 2021"));
```

如果传给 Date.parse()的字符串并不表示日期，则该方法会返回 NaN。如果直接把表示日期的字符串传给 Date 构造函数，那么 Date 会在后台调用 Date.parse()。换句话说，下面这行代码跟前面那行代码是等价的：

```js
let someDate = new Date("Aug 07, 2021");
```

这两行代码得到的日期对象相同。

注意 不同的浏览器对 Date 类型的实现有很多问题。比如，很多浏览器会选择用当前日期替代越界的日期，因此有些浏览器会将"January 32, 2019"解释为"February 1,2019"。Opera 则会插入当前月的当前日，返回"January 当前日, 2019"。就是说，如果是在 9 月 21 日运行代码，会返回"January 21, 2019"。

Date.UTC()方法也返回日期的毫秒表示，但使用的是跟 Date.parse()不同的信息来生成这个值。传给 Date.UTC()的参数是年、零起点月数（1 月是 0，2 月是 1，以此类推）、日（1~31）、时（0~23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默认为 1 日。其他参数的默认值都是 0。下面是使用 Date.UTC()的两个例子：

```js
// GMT 时间2000 年1 月1 日零点
let y2k = new Date(Date.UTC(2000, 0));

// GMT 时间2005 年5 月5 日下午5 点55 分55 秒
let allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));
```

这个例子创建了两个日期 。第一个日期是 2000 年 1 月 1 日零点（GMT），2000 代表年，0 代表月（1 月）。因为没有其他参数（日取 1，其他取 0），所以结果就是该月第 1 天零点。第二个日期表示 2005 年 5 月 5 日下午 5 点 55 分 55 秒（GMT）。虽然日期里面涉及的都是 5，但月数必须用 4，因为月数是零起点的。小时也必须是 17，因为这里采用的是 24 小时制，即取值范围是 0~23。其他参数就都很直观了。

与 Date.parse()一样，Date.UTC()也会被 Date 构造函数隐式调用，但有一个区别：这种情况下创建的是本地日期，不是 GMT 日期。不过 Date 构造函数跟 Date.UTC()接收的参数是一样的。因此，如果第一个参数是数值，则构造函数假设它是日期中的年，第二个参数就是月，以此类推。前面的例子也可以这样来写：

```js
// 本地时间2000 年1 月1 日零点
let y2k = new Date(2000, 0);

// 本地时间2005 年5 月5 日下午5 点55 分55 秒
let allFives = new Date(2005, 4, 5, 17, 55, 55);
```

以上代码创建了与前面例子中相同的两个日期，但这次的两个日期是（由于系统设置决定的）本地时区的日期。

ECMAScript 还提供了 Date.now()方法，返回表示方法执行时日期和时间的毫秒数。这个方法可以方便地用在代码分析中：

```js
// 起始时间
let start = Date.now();

// 调用函数
doSomething();

// 结束时间
let stop = Date.now(),
  result = stop - start;
```

### 5.1.1. 继承的方法

与其他类型一样，Date 类型重写了 toLocaleString()、toString()和 valueOf()方法。但与其他类型不同，重写后这些方法的返回值不一样。Date 类型的 toLocaleString()方法返回与浏览器运行的本地环境一致的日期和时间。这通常意味着格式中包含针对时间的 AM（上午）或 PM（下午），但不包含时区信息（具体格式可能因浏览器而不同）。toString()方法通常返回带时区信息的日期和时间，而时间也是以 24 小时制（0~23）表示的。下面给出了 toLocaleString()和 toString()返回的 2019 年 2 月 1 日零点的示例（地区为"en-US"的 PST，即 Pacific Standard Time，太平洋标准时间）：

toLocaleString() - 2/1/2019 12:00:00 AM
toString() - Thu Feb 1 2019 00:00:00 GMT-0800 (Pacific Standard Time)

现代浏览器在这两个方法的输出上已经趋于一致。在比较老的浏览器上，每个方法返回的结果可能在每个浏览器上都是不同的。这些差异意味着 toLocaleString()和 toString()可能只对调试有用，不能用于显示。

Date 类型的 valueOf()方法根本就不返回字符串，这个方法被重写后返回的是日期的毫秒表示。因此，操作符（如小于号和大于号）可以直接使用它返回的值。比如下面的例子：

```js
let date1 = new Date(2019, 0, 1); // 2019 年1 月1 日
let date2 = new Date(2019, 1, 1); // 2019 年2 月1 日

console.log(date1 < date2); // true
console.log(date1 > date2); // false
```

日期 2019 年 1 月 1 日在 2019 年 2 月 1 日之前，所以说前者小于后者没问题。因为 2019 年 1 月 1 日的毫秒表示小于 2019 年 2 月 1 日的毫秒表示，所以用小于号比较这两个日期时会返回 true。这也是确保日期先后的一个简单方式。

### 5.1.2. 日期格式化方法

Date 类型有几个专门用于格式化日期的方法，它们都会返回字符串：

- toDateString()显示日期中的周几、月、日、年（格式特定于实现）；
- toTimeString()显示日期中的时、分、秒和时区（格式特定于实现）；
- toLocaleDateString()显示日期中的周几、月、日、年（格式特定于实现和地区）；
- toLocaleTimeString()显示日期中的时、分、秒（格式特定于实现和地区）；
- toUTCString()显示完整的 UTC 日期（格式特定于实现）。

这些方法的输出与 toLocaleString()和 toString()一样，会因浏览器而异。因此不能用于在用户界面上一致地显示日期。

注意 还有一个方法叫 toGMTString()，这个方法跟 toUTCString()是一样的，目的是为了向后兼容。不过，规范建议新代码使用 toUTCString()。

### 5.1.3. 日期/时间组件方法

Date 类型剩下的方法（见下表）直接涉及取得或设置日期值的特定部分。注意表中“UTC 日期”，指的是没有时区偏移（将日期转换为 GMT）时的日期。

| 方 法                                       | 说 明                                                                                                      |
| ------------------------------------------- | ---------------------------------------------------------------------------------------------------------- |
| getTime()                                   | 返回日期的毫秒表示；与 valueOf()相同                                                                       |
| setTime(milliseconds)                       | 设置日期的毫秒表示，从而修改整个日期                                                                       |
| getFullYear()                               | 返回 4 位数年（即 2019 而不是 19）                                                                         |
| getUTCFullYear()                            | 返回 UTC 日期的 4 位数年                                                                                   |
| setFullYear(year)                           | 设置日期的年（year 必须是 4 位数）                                                                         |
| setUTCFullYear(year)                        | 设置 UTC 日期的年（year 必须是 4 位数）                                                                    |
| getMonth()                                  | 返回日期的月（0 表示 1 月，11 表示 12 月）                                                                 |
| getUTCMonth()                               | 返回 UTC 日期的月（0 表示 1 月，11 表示 12 月）                                                            |
| setMonth(month)                             | 设置日期的月（month 为大于 0 的数值，大于 11 加年）                                                        |
| setUTCMonth(month)                          | 设置 UTC 日期的月（month 为大于 0 的数值，大于 11 加年）                                                   |
| getDate()                                   | 返回日期中的日（1~31）                                                                                     |
| getUTCDate()                                | 返回 UTC 日期中的日（1~31）                                                                                |
| setDate(date)                               | 设置日期中的日（如果 date 大于该月天数，则加月）                                                           |
| setUTCDate(date)                            | 设置 UTC 日期中的日（如果 date 大于该月天数，则加月）                                                      |
| getDay()                                    | 返回日期中表示周几的数值（0 表示周日，6 表示周六）                                                         |
| getUTCDay()                                 | 返回 UTC 日期中表示周几的数值（0 表示周日，6 表示周六）                                                    |
| getHours() 返回日期中的时（0~23）           |
| getUTCHours()                               | 返回 UTC 日期中的时（0~23）                                                                                |
| setHours(hours)                             | 设置日期中的时（如果 hours 大于 23，则加日）                                                               |
| setUTCHours(hours)                          | 设置 UTC 日期中的时（如果 hours 大于 23，则加日）                                                          |
| getMinutes()                                | 返回日期中的分（0~59）                                                                                     |
| getUTCMinutes() 返回 UTC 日期中的分（0~59） |
| setMinutes(minutes)                         | 设置日期中的分（如果 minutes 大于 59，则加时）                                                             |
| setUTCMinutes(minutes)                      | 设置 UTC 日期中的分（如果 minutes 大于 59，则加时）                                                        |
| getSeconds()                                | 返回日期中的秒（0~59）                                                                                     |
| getUTCSeconds()                             | 返回 UTC 日期中的秒（0~59）                                                                                |
| setSeconds(seconds)                         | 设置日期中的秒（如果 seconds 大于 59，则加分）                                                             |
| setUTCSeconds(seconds)                      | 设置 UTC 日期中的秒（如果 seconds 大于 59，则加分）                                                        |
| getMilliseconds()                           | 返回日期中的毫秒                                                                                           |
| getUTCMilliseconds()                        | 返回 UTC 日期中的毫秒                                                                                      |
| setMilliseconds(milliseconds)               | 设置日期中的毫秒                                                                                           |
| setUTCMilliseconds(milliseconds)            | 设置 UTC 日期中的毫秒                                                                                      |
| getTimezoneOffset()                         | 返回以分钟计的 UTC 与本地时区的偏移量（如美国 EST 即“东部标准时间”返回 300，进入夏令时的地区可能有所差异） |

下面是一个演示：

```js
function getTime(date) {
  return `${date.getFullYear()}-${
    date.getMonth() + 1
  }-${date.getDate()} ${date.getHours()}:${date.getMinutes()}:${date.getSeconds()} ${date.getMilliseconds()}ms`;
}
console.log(getTime(new Date())); // 2021-8-7 17:55:40 837ms
```

## 5.2. RegExp

ECMAScript 通过 RegExp 类型支持正则表达式。正则表达式使用类似 Perl 的简洁语法来创建：

```js
let expression = /pattern/flags;
```

这个正则表达式的 pattern（模式）可以是任何简单或复杂的正则表达式，包括字符类、限定符、分组、向前查找和反向引用。每个正则表达式可以带零个或多个 flags（标记），用于控制正则表达式的行为。下面给出了表示匹配模式的标记。

- g：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。
- i：不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写。
- m：多行模式，表示查找到一行文本末尾时会继续查找。
- y：粘附模式，表示只查找从 lastIndex 开始及之后的字符串。
- u：Unicode 模式，启用 Unicode 匹配。
- s：dotAll 模式，表示元字符.匹配任何字符（包括\n 或\r）。

使用不同模式和标记可以创建出各种正则表达式，比如：

```js
// 匹配字符串中的所有"at"
let pattern1 = /at/g;

// 匹配第一个"bat"或"cat"，忽略大小写
let pattern2 = /[bc]at/i;

// 匹配所有以"at"结尾的三字符组合，忽略大小写
let pattern3 = /.at/gi;
```

与其他语言中的正则表达式类似，所有元字符在模式中也必须转义，包括：

( [ { \ ^ $ | ) ] } ? \* + .

元字符在正则表达式中都有一种或多种特殊功能，所以要匹配上面这些字符本身，就必须使用反斜杠来转义。下面是几个例子：

```js
// 匹配第一个"bat"或"cat"，忽略大小写
let pattern1 = /[bc]at/i;

// 匹配第一个"[bc]at"，忽略大小写
let pattern2 = /\[bc\]at/i;

// 匹配所有以"at"结尾的三字符组合，忽略大小写
let pattern3 = /.at/gi;

// 匹配所有".at"，忽略大小写
let pattern4 = /\.at/gi;
```

这里的 pattern1 匹配"bat"或"cat"，不区分大小写。要直接匹配"\[bc\]at"，左右中括号都必须像 pattern2 中那样使用反斜杠转义。在 pattern3 中，点号表示"at"前面的任意字符都可以匹配。如果想匹配".at"，那么要像 pattern4 中那样对点号进行转义。

前面例子中的正则表达式都是使用字面量形式定义的。正则表达式也可以使用 RegExp 构造函数来创建，它接收两个参数：模式字符串和（可选的）标记字符串。任何使用字面量定义的正则表达式也可以通过构造函数来创建，比如：

```js
// 匹配第一个"bat"或"cat"，忽略大小写
let pattern1 = /[bc]at/i;

// 跟pattern1 一样，只不过是用构造函数创建的
let pattern2 = new RegExp("[bc]at", "i");
```

这里的 pattern1 和 pattern2 是等效的正则表达式。注意，RegExp 构造函数的两个参数都是字符串。因为 RegExp 的模式参数是字符串，所以在某些情况下需要二次转义。所有元字符都必须二次转义，包括转义字符序列，如\n（\转义后的字符串是\\，在正则表达式字符串中则要写成\\\\）。下表展示了几个正则表达式的字面量形式，以及使用 RegExp 构造函数创建时对应的模式字符串。

| 字面量模式         | 对应的字符串            |
| ------------------ | ----------------------- |
| `/\[bc\]at/`       | `"\\[bc\\]at"`          |
| `/\.at/ `          | `"\\.at"`               |
| `/name\/age/`      | `"name\\/age"`          |
| `/\d.\d{1,2}/`     | `"\\d.\\d{1,2}"`        |
| `/\w\\hello\\123/` | `"\\w\\\\hello\\\\123"` |

此外，使用 RegExp 也可以基于已有的正则表达式实例，并可选择性地修改它们的标记：

```js
const re1 = /cat/g;
console.log(re1); // "/cat/g"

const re2 = new RegExp(re1);
console.log(re2); // "/cat/g"

const re3 = new RegExp(re1, "i");
console.log(re3); // "/cat/i"
```

### 5.2.1. RegExp 实例属性

每个 RegExp 实例都有下列属性，提供有关模式的各方面信息。

- global：布尔值，表示是否设置了 g 标记。
- ignoreCase：布尔值，表示是否设置了 i 标记。
- unicode：布尔值，表示是否设置了 u 标记。
- sticky：布尔值，表示是否设置了 y 标记。
- lastIndex：整数，表示在源字符串中下一次搜索的开始位置，始终从 0 开始。
- multiline：布尔值，表示是否设置了 m 标记。
- dotAll：布尔值，表示是否设置了 s 标记。
- source：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。
- flags：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）。

通过这些属性可以全面了解正则表达式的信息，不过实际开发中用得并不多，因为模式声明中包含这些信息。下面是一个例子：

```js
let pattern1 = /\[bc\]at/i;

console.log(pattern1.global); // false
console.log(pattern1.ignoreCase); // true
console.log(pattern1.multiline); // false
console.log(pattern1.lastIndex); // 0
console.log(pattern1.source); // "\[bc\]at"
console.log(pattern1.flags); // "i"

let pattern2 = new RegExp("\\[bc\\]at", "i");

console.log(pattern2.global); // false
console.log(pattern2.ignoreCase); // true
console.log(pattern2.multiline); // false
console.log(pattern2.lastIndex); // 0
console.log(pattern2.source); // "\[bc\]at"
console.log(pattern2.flags); // "i"
```

注意，虽然第一个模式是通过字面量创建的，第二个模式是通过 RegExp 构造函数创建的，但两个模式的 source 和 flags 属性是相同的。source 和 flags 属性返回的是规范化之后可以在字面量中使用的形式。

### 5.2.2. RegExp 实例方法

RegExp 实例的主要方法是 exec()，主要用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，则返回包含第一个匹配信息的数组；如果没找到匹配项，则返回 null。返回的数组虽然是 Array 的实例，但包含两个额外的属性：index 和 input。index 是字符串中匹配模式的起始位置，input 是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串。如果模式中没有捕获组，则数组只包含一个元素。来看下面的例子：

```js
let text = "mom and dad and baby";
let pattern = /mom( and dad( and baby)?)?/gi;

let matches = pattern.exec(text);
console.log(matches.index); // 0
console.log(matches.input); // "mom and dad and baby"
console.log(matches[0]); // "mom and dad and baby"
console.log(matches[1]); // " and dad and baby"
console.log(matches[2]); // " and baby"
```

在这个例子中，模式包含两个捕获组：最内部的匹配项" and baby"，以及外部的匹配项" and dad"或" and dad and baby"。调用 exec()后找到了一个匹配项。因为整个字符串匹配模式，所以 matchs 数组的 index 属性就是 0。数组的第一个元素是匹配的整个字符串，第二个元素是匹配第一个捕获组的字符串，第三个元素是匹配第二个捕获组的字符串。

如果模式设置了全局标记，则每次调用 exec()方法会返回一个匹配的信息。如果没有设置全局标记，则无论对同一个字符串调用多少次 exec()，也只会返回第一个匹配的信息。

```js
let text = "cat, bat, sat, fat";
let pattern = /.at/;

let matches = pattern.exec(text);
console.log(matches.index); // 0
console.log(matches[0]); // cat
console.log(pattern.lastIndex); // 0

matches = pattern.exec(text);
console.log(matches.index); // 0
console.log(matches[0]); // cat
console.log(pattern.lastIndex); // 0
```

上面例子中的模式没有设置全局标记，因此调用 exec()只返回第一个匹配项（"cat"）。lastIndex 在非全局模式下始终不变。

如果在这个模式上设置了 g 标记，则每次调用 exec()都会在字符串中向前搜索下一个匹配项，如下面的例子所示：

```js
let text = "cat, bat, sat, fat";
let pattern = /.at/g;
let matches = pattern.exec(text);
console.log(matches.index); // 0
console.log(matches[0]); // cat
console.log(pattern.lastIndex); // 3

matches = pattern.exec(text);
console.log(matches.index); // 5
console.log(matches[0]); // bat
console.log(pattern.lastIndex); // 8

matches = pattern.exec(text);
console.log(matches.index); // 10
console.log(matches[0]); // sat
console.log(pattern.lastIndex); // 13
```

这次模式设置了全局标记，因此每次调用 exec()都会返回字符串中的下一个匹配项，直到搜索到字符串末尾。注意模式的 lastIndex 属性每次都会变化。在全局匹配模式下，每次调用 exec()都会更新 lastIndex 值，以反映上次匹配的最后一个字符的索引。

如果模式设置了粘附标记 y，则每次调用 exec()就只会在 lastIndex 的位置上寻找匹配项。粘附标记覆盖全局标记。

```js
let text = "cat, bat, sat, fat";
let pattern = /.at/y;
let matches = pattern.exec(text);
console.log(matches.index); // 0
console.log(matches[0]); // cat
console.log(pattern.lastIndex); // 3

// 以索引3 对应的字符开头找不到匹配项，因此exec()返回null
// exec()没找到匹配项，于是将lastIndex 设置为0
matches = pattern.exec(text);
console.log(matches); // null
console.log(pattern.lastIndex); // 0

// 向前设置lastIndex 可以让粘附的模式通过exec()找到下一个匹配项：
pattern.lastIndex = 5;
matches = pattern.exec(text);
console.log(matches.index); // 5
console.log(matches[0]); // bat
console.log(pattern.lastIndex); // 8
```

正则表达式的另一个方法是 test()，接收一个字符串参数。如果输入的文本与模式匹配，则参数返回 true，否则返回 false。这个方法适用于只想测试模式是否匹配，而不需要实际匹配内容的情况。test()经常用在 if 语句中：

```js
let text = "000-00-0000";
let pattern = /\d{3}-\d{2}-\d{4}/;

if (pattern.test(text)) {
  console.log("The pattern was matched.");
}
```

在这个例子中，正则表达式用于测试特定的数值序列。如果输入的文本与模式匹配，则显示匹配成功的消息。这个用法常用于验证用户输入，此时我们只在乎输入是否有效，不关心为什么无效。

无论正则表达式是怎么创建的，继承的方法 toLocaleString()和 toString()都返回正则表达式的字面量表示。比如：

```js
let pattern = new RegExp("\\[bc\\]at", "gi");
console.log(pattern.toString()); // /\[bc\]at/gi
console.log(pattern.toLocaleString()); // /\[bc\]at/gi
```

这里的模式是通过 RegExp 构造函数创建的，但 toLocaleString()和 toString()返回的都是其字面量的形式。

注意 正则表达式的 valueOf()方法返回正则表达式本身。

### 5.2.3. RegExp 构造函数属性

RegExp 构造函数本身也有几个属性。（在其他语言中，这种属性被称为静态属性。）这些属性适用于作用域中的所有正则表达式，而且会根据最后执行的正则表达式操作而变化。这些属性还有一个特点，就是可以通过两种不同的方式访问它们。换句话说，每个属性都有一个全名和一个简写。下表列出了 RegExp 构造函数的属性。

| 全 名        | 简 写                                        | 说 明 |
| ------------ | -------------------------------------------- | ----- |
| input        | $\_ 最后搜索的字符串（非标准特性）           |
| lastMatch    | $& 最后匹配的文本                            |
| lastParen    | $+ 最后匹配的捕获组（非标准特性）            |
| leftContext  | $` input 字符串中出现在 lastMatch 前面的文本 |
| rightContext | $' input 字符串中出现在 lastMatch 后面的文本 |

通过这些属性可以提取出与exec()和test()执行的操作相关的信息。来看下面的例子：

```js
let text = "this has been a short summer";
let pattern = /(.)hort/g;

if (pattern.test(text)) {
console.log(RegExp.input); // this has been a short summer
console.log(RegExp.leftContext); // this has been a
console.log(RegExp.rightContext); // summer
console.log(RegExp.lastMatch); // short
console.log(RegExp.lastParen); // s
}
```

以上代码创建了一个模式，用于搜索任何后跟"hort"的字符，并把第一个字符放在了捕获组中。不同属性包含的内容如下。

- input 属性中包含原始的字符串。
- leftConext 属性包含原始字符串中"short"之前的内容，rightContext 属性包含"short"之后的内容。
- lastMatch 属性包含匹配整个正则表达式的上一个字符串，即"short"。
- lastParen 属性包含捕获组的上一次匹配，即"s"。

这些属性名也可以替换成简写形式，只不过要使用中括号语法来访问，如下面的例子所示，因为大多数简写形式都不是合法的ECMAScript 标识符：

```js
let text = "this has been a short summer";
let pattern = /(.)hort/g;

/*
* 注意：Opera 不支持简写属性名
* IE 不支持多行匹配
*/
if (pattern.test(text)) {
console.log(RegExp.$_); // this has been a short summer
console.log(RegExp["$`"]); // this has been a
console.log(RegExp["$'"]); // summer
console.log(RegExp["$&"]); // short
console.log(RegExp["$+"]); // s
}
```

RegExp 还有其他几个构造函数属性，可以存储最多9 个捕获组的匹配项。这些属性通过RegExp.$1~RegExp.$9 来访问，分别包含第1~9 个捕获组的匹配项。在调用exec()或test()时，这些属性就会被填充，然后就可以像下面这样使用它们：

```js
let text = "this has been a short summer";
let pattern = /(..)or(.)/g;
if (pattern.test(text)) {
  console.log(RegExp.$1); // sh
  console.log(RegExp.$2); // t
}
```

在这个例子中，模式包含两个捕获组。调用test()搜索字符串之后，因为找到了匹配项所以返回true，而且可以打印出通过RegExp 构造函数的$1 和$2 属性取得的两个捕获组匹配的内容。

注意 RegExp 构造函数的所有属性都没有任何Web 标准出处，因此不要在生产环境中使用它们。

### 5.2.4. 模式局限

虽然ECMAScript 对正则表达式的支持有了长足的进步，但仍然缺少Perl 语言中的一些高级特性。下列特性目前还没有得到ECMAScript 的支持（想要了解更多信息，可以参考Regular-Expressions.info网站）：

- \A 和\Z 锚（分别匹配字符串的开始和末尾）
- 联合及交叉类
- 原子组
- x（忽略空格）匹配模式
- 条件式匹配
- 正则表达式注释

虽然还有这些局限，但ECMAScript 的正则表达式已经非常强大，可以用于大多数模式匹配任务。

## 5.3. 原始值包装类型

为了方便操作原始值，ECMAScript 提供了3 种特殊的引用类型：Boolean、Number 和String。这些类型具有本章介绍的其他引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。来看下面的例子：

```js
let s1 = "some text";
let s2 = s1.substring(2);
```

在这里，s1 是一个包含字符串的变量，它是一个原始值。第二行紧接着在s1 上调用了substring()方法，并把结果保存在s2 中。我们知道，原始值本身不是对象，因此逻辑上不应该有方法。而实际上这个例子又确实按照预期运行了。这是因为后台进行了很多处理，从而实现了上述操作。具体来说，当第二行访问s1 时，是以读模式访问的，也就是要从内存中读取变量保存的值。在以读模式访问字符串值的任何时候，后台都会执行以下3 步：

1. 创建一个String 类型的实例；
2. 调用实例上的特定方法；
3. 销毁实例。

可以把这3 步想象成执行了如下3 行ECMAScript 代码：

```js
let s1 = new String("some text");
let s2 = s1.substring(2);
s1 = null;
```

这种行为可以让原始值拥有对象的行为。对布尔值和数值而言，以上3 步也会在后台发生，只不过使用的是Boolean 和Number 包装类型而已。

引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过new 实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间。这意味着不能在运行时给原始值添加属性和方法。比如下面的例子：

```js
let s1 = "some text";
s1.color = "red";
console.log(s1.color); // undefined
```

这里的第二行代码尝试给字符串s1 添加了一个color 属性。可是，第三行代码访问color 属性时，它却不见了。原因就是第二行代码运行时会临时创建一个String 对象，而当第三行代码执行时，这个对象已经被销毁了。实际上，第三行代码在这里创建了自己的String 对象，但这个对象没有color 属性。

可以显式地使用Boolean、Number 和String 构造函数创建原始值包装对象。不过应该在确实必要时再这么做，否则容易让开发者疑惑，分不清它们到底是原始值还是引用值。在原始值包装类型的实例上调用typeof 会返回"object"，所有原始值包装对象都会转换为布尔值true。

另外，Object 构造函数作为一个工厂方法，能够根据传入值的类型返回相应原始值包装类型的实例。比如：

```js
let obj = new Object("some text");
console.log(obj instanceof String); // true
```

如果传给Object 的是字符串，则会创建一个String 的实例。如果是数值，则会创建Number 的实例。布尔值则会得到Boolean 的实例。

注意，使用new 调用原始值包装类型的构造函数，与调用同名的转型函数并不一样。例如：

```js
let value = "25";
let number = Number(value); // 转型函数
console.log(typeof number); // "number"
let obj = new Number(value); // 构造函数
console.log(typeof obj); // "object"
```

在这个例子中，变量number 中保存的是一个值为25 的原始数值，而变量obj 中保存的是一个Number 的实例。

虽然不推荐显式创建原始值包装类型的实例，但它们对于操作原始值的功能是很重要的。每个原始值包装类型都有相应的一套方法来方便数据操作。

### 5.3.1. Boolean

Boolean 是对应布尔值的引用类型。要创建一个Boolean 对象，就使用Boolean 构造函数并传入true 或false，如下例所示：

```js
let booleanObject = new Boolean(true);
```

Boolean 的实例会重写valueOf()方法，返回一个原始值true 或false。toString()方法被调用时也会被覆盖，返回字符串"true"或"false"。不过，Boolean 对象在ECMAScript 中用得很少。不仅如此，它们还容易引起误会，尤其是在布尔表达式中使用Boolean 对象时，比如：

```js
let falseObject = new Boolean(false);
let result = falseObject && true;
console.log(result); // true

let falseValue = false;
result = falseValue && true;
console.log(result); // false
```

在这段代码中，我们创建一个值为false 的Boolean 对象。然后，在一个布尔表达式中通过&&操作将这个对象与一个原始值true 组合起来。在布尔算术中，false && true 等于false。可是，这个表达式是对falseObject 对象而不是对它表示的值（false）求值。前面刚刚说过，所有对象在布尔表达式中都会自动转换为true，因此falseObject 在这个表达式里实际上表示一个true 值。那么true && true 当然是true。

除此之外，原始值和引用值（Boolean 对象）还有几个区别。首先，typeof 操作符对原始值返回"boolean"，但对引用值返回"object"。同样，Boolean 对象是Boolean 类型的实例，在使用instaceof 操作符时返回true，但对原始值则返回false，如下所示：

```js
console.log(typeof falseObject); // object
console.log(typeof falseValue); // boolean
console.log(falseObject instanceof Boolean); // true
console.log(falseValue instanceof Boolean); // false
```

理解原始布尔值和Boolean 对象之间的区别非常重要，强烈建议永远不要使用后者。

### 5.3.2. Number

Number 是对应数值的引用类型。要创建一个Number 对象，就使用Number 构造函数并传入一个数值，如下例所示：

```js
let numberObject = new Number(10);
```

与Boolean 类型一样，Number 类型重写了valueOf()、toLocaleString()和toString()方法。valueOf()方法返回Number 对象表示的原始数值，另外两个方法返回数值字符串。toString()方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串，如下所示：

```js
let num = 10;
console.log(num.toString()); // "10"
console.log(num.toString(2)); // "1010"
console.log(num.toString(8)); // "12"
console.log(num.toString(10)); // "10"
console.log(num.toString(16)); // "a"
```

除了继承的方法，Number 类型还提供了几个用于将数值格式化为字符串的方法。

toFixed()方法返回包含指定小数点位数的数值字符串，如：

```js
let num = 10;
console.log(num.toFixed(2)); // "10.00"
```

这里的toFixed()方法接收了参数2，表示返回的数值字符串要包含两位小数。结果返回值为"10.00"，小数位填充了0。如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的小数位：

```js
let num = 10.005;
console.log(num.toFixed(2)); // "10.01"
```

toFixed()自动舍入的特点可以用于处理货币。不过要注意的是，多个浮点数值的数学计算不一定得到精确的结果。比如，0.1 + 0.2 = 0.30000000000000004。

注意 toFixed()方法可以表示有0~20 个小数位的数值。某些浏览器可能支持更大的范围，但这是通常被支持的范围。

另一个用于格式化数值的方法是toExponential()，返回以科学记数法（也称为指数记数法）表示的数值字符串。与toFixed()一样，toExponential()也接收一个参数，表示结果中小数的位数。来看下面的例子：

```js
let num = 10;
console.log(num.toExponential(1)); // "1.0e+1"
```

这段代码的输出为"1.0e+1"。一般来说，这么小的数不用表示为科学记数法形式。如果想得到数值最适当的形式，那么可以使用toPrecision()。

toPrecision()方法会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法形式。这个方法接收一个参数，表示结果中数字的总位数（不包含指数）。来看几个例子：

```js
let num = 99;
console.log(num.toPrecision(1)); // "1e+2"
console.log(num.toPrecision(2)); // "99"
console.log(num.toPrecision(3)); // "99.0"
```

在这个例子中，首先要用1 位数字表示数值99，得到"1e+2"，也就是100。因为99 不能只用1 位数字来精确表示，所以这个方法就将它舍入为100，这样就可以只用1 位数字（及其科学记数法形式）来表示了。用2 位数字表示99 得到"99"，用3 位数字则是"99.0"。本质上，toPrecision()方法会根据数值和精度来决定调用toFixed()还是toExponential()。为了以正确的小数位精确表示数值，这3 个方法都会向上或向下舍入。

与Boolean 对象类似，Number 对象也为数值提供了重要能力。但是，考虑到两者存在同样的潜在问题，因此并不建议直接实例化Number 对象。在处理原始数值和引用数值时，typeof 和instacnceof操作符会返回不同的结果，如下所示：

```js
let numberObject = new Number(10);
let numberValue = 10;
console.log(typeof numberObject); // "object"
console.log(typeof numberValue); // "number"
console.log(numberObject instanceof Number); // true
console.log(numberValue instanceof Number); // false
```

原始数值在调用typeof 时始终返回"number"，而Number 对象则返回"object"。类似地，Number对象是Number 类型的实例，而原始数值不是。

**isInteger()方法与安全整数**

ES6 新增了Number.isInteger()方法，用于辨别一个数值是否保存为整数。有时候，小数位的0可能会让人误以为数值是一个浮点值：

```js
console.log(Number.isInteger(1)); // true
console.log(Number.isInteger(1.00)); // true
console.log(Number.isInteger(1.01)); // false
```

IEEE 754 数值格式有一个特殊的数值范围，在这个范围内二进制值可以表示一个整数值。这个数值范围从Number.MIN_SAFE_INTEGER（-2^53 + 1）到Number.MAX_SAFE_INTEGER（2^53 - 1）。对超出这个范围的数值，即使尝试保存为整数，IEEE 754 编码格式也意味着二进制值可能会表示一个完全不同的数值。为了鉴别整数是否在这个范围内，可以使用Number.isSafeInteger()方法：

```js
console.log(Number.isSafeInteger(-1 * (2 ** 53))); // false
console.log(Number.isSafeInteger(-1 * (2 ** 53) + 1)); // true
console.log(Number.isSafeInteger(2 ** 53)); // false
console.log(Number.isSafeInteger((2 ** 53) - 1)); // true
```

### 5.3.3. String

String 是对应字符串的引用类型。要创建一个String 对象，使用String 构造函数并传入一个数值，如下例所示：

```js
let stringObject = new String("hello world");
```

String 对象的方法可以在所有字符串原始值上调用。3 个继承的方法valueOf()、toLocaleString()和toString()都返回对象的原始字符串值。

每个String 对象都有一个length 属性，表示字符串中字符的数量。来看下面的例子：

```js
let stringValue = "hello world";
console.log(stringValue.length); // "11"
```

这个例子输出了字符串"hello world"中包含的字符数量：11。注意，即使字符串中包含双字节字符（而不是单字节的ASCII 字符），也仍然会按单字符来计数。

String 类型提供了很多方法来解析和操作字符串。

1. **JavaScript 字符**

JavaScript 字符串由16 位码元（code unit）组成。对多数字符来说，每16 位码元对应一个字符。换句话说，字符串的length 属性表示字符串包含多少16 位码元：

```js
let message = "abcde";
console.log(message.length); // 5
```

此外，charAt()方法返回给定索引位置的字符，由传给方法的整数参数指定。具体来说，这个方法查找指定索引位置的16 位码元，并返回该码元对应的字符：

```js
let message = "abcde";
console.log(message.charAt(2)); // "c"
```

JavaScript 字符串使用了两种Unicode 编码混合的策略：UCS-2 和UTF-16。对于可以采用16 位编码的字符（U+0000~U+FFFF），这两种编码实际上是一样的。

注意 要深入了解关于字符编码的内容，推荐Joel Spolsky 写的博客文章：“The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)”。另一个有用的资源是Mathias Bynens 的博文：“JavaScript’s Internal Character Encoding: UCS-2 or UTF-16?”。

使用charCodeAt()方法可以查看指定码元的字符编码。这个方法返回指定索引位置的码元值，索引以整数指定。比如：

```js
let message = "abcde";

// Unicode "小写拉丁字母 C"的编码是U+0063
console.log(message.charCodeAt(2)); // 99

// 十进制99 等于十六进制63
console.log(99 === 0x63); // true
```

fromCharCode()方法用于根据给定的UTF-16 码元创建字符串中的字符。这个方法可以接受任意多个数值，并返回将所有数值对应的字符拼接起来的字符串：

```js
// Unicode "小写拉丁字母 A"的编码是U+0061
// Unicode "小写拉丁字母 B"的编码是U+0062
// Unicode "小写拉丁字母 C"的编码是U+0063
// Unicode "小写拉丁字母 D"的编码是U+0064
// Unicode "小写拉丁字母 E"的编码是U+0065
console.log(String.fromCharCode(0x61, 0x62, 0x63, 0x64, 0x65)); // "abcde"
// 0x0061 === 97
// 0x0062 === 98
// 0x0063 === 99
// 0x0064 === 100
// 0x0065 === 101
console.log(String.fromCharCode(97, 98, 99, 100, 101)); // "abcde"
```

对于U+0000~U+FFFF 范围内的字符，length、charAt()、charCodeAt()和fromCharCode()返回的结果都跟预期是一样的。这是因为在这个范围内，每个字符都是用16 位表示的，而这几个方法也都基于16 位码元完成操作。只要字符编码大小与码元大小一一对应，这些方法就能如期工作。

这个对应关系在扩展到Unicode 增补字符平面时就不成立了。问题很简单，即16 位只能唯一表示65 536 个字符。这对于大多数语言字符集是足够了，在Unicode 中称为 **基本多语言平面(BMP)**。为了表示更多的字符，Unicode 采用了一个策略，即每个字符使用另外16 位去选择一个增补平面。这种每个字符使用两个16 位码元的策略称为 **代理对**。

在涉及增补平面的字符时，前面讨论的字符串方法就会出问题。比如，下面的例子中使用了一个笑脸表情符号，也就是一个使用代理对编码的字符：

```js
// "smiling face with smiling eyes" 表情符号的编码是U+1F60A
// 0x1F60A === 128522

let message = "ab☺de";
console.log(message.length); // 6
console.log(message.charAt(1)); // b
console.log(message.charAt(2)); // <?>
console.log(message.charAt(3)); // <?>
console.log(message.charAt(4)); // d
console.log(message.charCodeAt(1)); // 98
console.log(message.charCodeAt(2)); // 55357
console.log(message.charCodeAt(3)); // 56842
console.log(message.charCodeAt(4)); // 100
console.log(String.fromCodePoint(0x1F60A)); // ☺
console.log(String.fromCharCode(97, 98, 55357, 56842, 100, 101)); // ab☺de
```

这些方法仍然将16 位码元当作一个字符，事实上索引2 和索引3 对应的码元应该被看成一个代理对，只对应一个字符。fromCharCode()方法仍然返回正确的结果，因为它实际上是基于提供的二进制表示直接组合成字符串。浏览器可以正确解析代理对（由两个码元构成），并正确地将其识别为一个Unicode 笑脸字符。

为正确解析既包含单码元字符又包含代理对字符的字符串，可以使用codePointAt()来代替charCodeAt()。跟使用charCodeAt()时类似，codePointAt()接收16 位码元的索引并返回该索引位置上的码点（code point）。码点是Unicode 中一个字符的完整标识。比如，"c"的码点是0x0063，而"☺"的码点是0x1F60A。码点可能是16 位，也可能是32 位，而codePointAt()方法可以从指定码元位置识别完整的码点。

```js
let message = "ab☺de";
console.log(message.codePointAt(1)); // 98
console.log(message.codePointAt(2)); // 128522
console.log(message.codePointAt(3)); // 56842
console.log(message.codePointAt(4)); // 100
```

注意，如果传入的码元索引并非代理对的开头，就会返回错误的码点。这种错误只有检测单个字符的时候才会出现，可以通过从左到右按正确的码元数遍历字符串来规避。迭代字符串可以智能地识别代理对的码点：

```js
console.log([..."ab☺de"]); // ["a", "b", "☺", "d", "e"]
```

与charCodeAt()有对应的codePointAt()一样，fromCharCode()也有一个对应的fromCodePoint()。这个方法接收任意数量的码点，返回对应字符拼接起来的字符串：

```js
console.log(String.fromCharCode(97, 98, 55357, 56842, 100, 101)); // ab☺de
console.log(String.fromCodePoint(97, 98, 128522, 100, 101)); // ab☺de
```

2. **normalize 方法**

某些Unicode 字符可以有多种编码方式。有的字符既可以通过一个BMP 字符表示，也可以通过一个代理对表示。比如：

```js
// U+00C5：上面带圆圈的大写拉丁字母A
console.log(String.fromCharCode(0x00C5)); // Å
// U+212B：长度单位“埃”
console.log(String.fromCharCode(0x212B)); // Å
// U+004：大写拉丁字母A
// U+030A：上面加个圆圈
console.log(String.fromCharCode(0x0041, 0x030A)); // Å
```

比较操作符不在乎字符看起来是什么样的，因此这3 个字符互不相等。

```js
let a1 = String.fromCharCode(0x00C5),
  a2 = String.fromCharCode(0x212B),
  a3 = String.fromCharCode(0x0041, 0x030A);

console.log(a1, a2, a3); // Å, Å, Å
console.log(a1 === a2); // false
console.log(a1 === a3); // false
console.log(a2 === a3); // false
```

为解决这个问题，Unicode 提供了4 种规范化形式，可以将类似上面的字符规范化为一致的格式，无论底层字符的代码是什么。这4 种规范化形式是：NFD（Normalization Form D）、NFC（Normalization Form C）、NFKD（Normalization Form KD）和NFKC（Normalization Form KC）。可以使用normalize()方法对字符串应用上述规范化形式，使用时需要传入表示哪种形式的字符串："NFD"、"NFC"、"NFKD"或"NFKC"。

注意 这4 种规范化形式的具体细节超出了本书范围，有兴趣的读者可以自行参考UAX15#: Unicode Normalization Forms 中的1.2 节“Normalization Forms”。

通过比较字符串与其调用normalize()的返回值，就可以知道该字符串是否已经规范化了：

```js
let a1 = String.fromCharCode(0x00C5),
  a2 = String.fromCharCode(0x212B),
  a3 = String.fromCharCode(0x0041, 0x030A);
// U+00C5 是对0+212B 进行NFC/NFKC 规范化之后的结果
console.log(a1 === a1.normalize("NFD")); // false
console.log(a1 === a1.normalize("NFC")); // true
console.log(a1 === a1.normalize("NFKD")); // false
console.log(a1 === a1.normalize("NFKC")); // true
// U+212B 是未规范化的
console.log(a2 === a2.normalize("NFD")); // false
console.log(a2 === a2.normalize("NFC")); // false
console.log(a2 === a2.normalize("NFKD")); // false
console.log(a2 === a2.normalize("NFKC")); // false
// U+0041/U+030A 是对0+212B 进行NFD/NFKD 规范化之后的结果
console.log(a3 === a3.normalize("NFD")); // true
console.log(a3 === a3.normalize("NFC")); // false
console.log(a3 === a3.normalize("NFKD")); // true
console.log(a3 === a3.normalize("NFKC")); // false
```

选择同一种规范化形式可以让比较操作符返回正确的结果：

```js
let a1 = String.fromCharCode(0x00C5),
  a2 = String.fromCharCode(0x212B),
  a3 = String.fromCharCode(0x0041, 0x030A);
console.log(a1.normalize("NFD") === a2.normalize("NFD")); // true
console.log(a2.normalize("NFKC") === a3.normalize("NFKC")); // true
console.log(a1.normalize("NFC") === a3.normalize("NFC")); // true
```

3. **字符串操作方法**

本节介绍几个操作字符串值的方法。首先是concat()，用于将一个或多个字符串拼接成一个新字符串。来看下面的例子：

```js
let stringValue = "hello ";
let result = stringValue.concat("world");
console.log(result); // "hello world"
console.log(stringValue); // "hello"
```

在这个例子中，对stringValue 调用concat()方法的结果是得到"hello world"，但stringValue 的值保持不变。concat()方法可以接收任意多个参数，因此可以一次性拼接多个字符串，如下所示：

```js
let stringValue = "hello ";
let result = stringValue.concat("world", "!");
console.log(result); // "hello world!"
console.log(stringValue); // "hello"
```

这个修改后的例子将字符串"world"和"!"追加到了"hello "后面。虽然concat()方法可以拼接字符串，但更常用的方式是使用加号操作符（+）。而且多数情况下，对于拼接多个字符串来说，使用加号更方便。

ECMAScript 提供了3 个从字符串中提取子字符串的方法：slice()、substr()和substring()。这3 个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。对slice()和substring()而言，第二个参数是提取结束的位置（即该位置之前的字符会被提取出来）。对substr()而言，第二个参数表示返回的子字符串数量。任何情况下，省略第二个参数都意味着提取到字符串末尾。与concat()方法一样，slice()、substr()和substring()也不会修改调用它们的字符串，而只会返回提取到的原始新字符串值。来看下面的例子：

```js
let stringValue = "hello world";
console.log(stringValue.slice(3)); // "lo world"
console.log(stringValue.substring(3)); // "lo world"
console.log(stringValue.substr(3)); // "lo world"
console.log(stringValue.slice(3, 7)); // "lo w"
console.log(stringValue.substring(3,7)); // "lo w"
console.log(stringValue.substr(3, 7)); // "lo worl"
```

 