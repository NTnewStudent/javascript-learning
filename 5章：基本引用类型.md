**目录：**
- [5. 基本引用类型](#5-基本引用类型)
  - [5.1. Date](#51-date)
    - [5.1.1. 继承的方法](#511-继承的方法)
    - [5.1.2. 日期格式化方法](#512-日期格式化方法)
    - [5.1.3. 日期/时间组件方法](#513-日期时间组件方法)
  - [5.2. RegExp](#52-regexp)
    - [5.2.1. RegExp 实例属性](#521-regexp-实例属性)
    - [5.2.2. RegExp 实例方法](#522-regexp-实例方法)

# 5. 基本引用类型

本章内容

- 理解对象
- 基本 JavaScript 数据类型
- 原始值与原始值包装类型

引用值（或者对象）是某个特定引用类型的实例。在 ECMAScript 中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”。虽然从技术上讲 JavaScript 是一门面向对象语言，但 ECMAScript 缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。

注意 引用类型虽然有点像类，但跟类并不是一个概念。为避免混淆，本章后面不会使用术语“类”。

对象被认为是某个特定引用类型的实例。新对象通过使用 new 操作符后跟一个 **构造函数(constructor)** 来创建。构造函数就是用来创建新对象的函数，比如下面这行代码：

```js
let now = new Date();
```

这行代码创建了引用类型 Date 的一个新实例，并将它保存在变量 now 中。Date()在这里就是构造函数，它负责创建一个只有默认属性和方法的简单对象。ECMAScript 提供了很多像 Date 这样的原生引用类型，帮助开发者实现常见的任务。

注意 函数也是一种引用类型，但有关函数的内容太多了，一章放不下，所以本书专门用第 10 章来介绍函数。

## 5.1. Date

ECMAScript 的 Date 类型参考了 Java 早期版本中的 java.util.Date。为此，Date 类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间 1970 年 1 月 1 日午夜（零时）至今所经过的毫秒数。使用这种存储格式，Date 类型可以精确表示 1970 年 1 月 1 日之前及之后 285 616 年的日期。

要创建日期对象，就使用 new 操作符来调用 Date 构造函数：

```js
let now = new Date();
```

在不给 Date 构造函数传参数的情况下，创建的对象将保存当前日期和时间。要基于其他日期和时间创建日期对象，必须传入其毫秒表示（UNIX 纪元 1970 年 1 月 1 日午夜之后的毫秒数）。ECMAScript 为此提供了两个辅助方法：Date.parse()和 Date.UTC()。

Date.parse()方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。ECMA-262 第 5 版定义了 Date.parse()应该支持的日期格式，填充了第 3 版遗留的空白。所有实现都必须支持下列日期格式：

- “月/日/年”，如"08/07/2021"；
- “月名 日, 年”，如"Aug 07, 2021"；
- “周几 月名 日 年 时:分:秒 时区”，如"Sat Aug 07 2021 00:00:00 GMT-0700"；
- ISO 8601 扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如 2021-08-07T00:00:00（只适用于
  兼容 ES5 的实现）。

比如，要创建一个表示“2021 年 08 月 07 日”的日期对象，可以使用以下代码：

```js
let someDate = new Date(Date.parse("Aug 07, 2021"));
```

如果传给 Date.parse()的字符串并不表示日期，则该方法会返回 NaN。如果直接把表示日期的字符串传给 Date 构造函数，那么 Date 会在后台调用 Date.parse()。换句话说，下面这行代码跟前面那行代码是等价的：

```js
let someDate = new Date("Aug 07, 2021");
```

这两行代码得到的日期对象相同。

注意 不同的浏览器对 Date 类型的实现有很多问题。比如，很多浏览器会选择用当前日期替代越界的日期，因此有些浏览器会将"January 32, 2019"解释为"February 1,2019"。Opera 则会插入当前月的当前日，返回"January 当前日, 2019"。就是说，如果是在 9 月 21 日运行代码，会返回"January 21, 2019"。

Date.UTC()方法也返回日期的毫秒表示，但使用的是跟 Date.parse()不同的信息来生成这个值。传给 Date.UTC()的参数是年、零起点月数（1 月是 0，2 月是 1，以此类推）、日（1~31）、时（0~23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默认为 1 日。其他参数的默认值都是 0。下面是使用 Date.UTC()的两个例子：

```js
// GMT 时间2000 年1 月1 日零点
let y2k = new Date(Date.UTC(2000, 0));

// GMT 时间2005 年5 月5 日下午5 点55 分55 秒
let allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));
```

这个例子创建了两个日期 。第一个日期是 2000 年 1 月 1 日零点（GMT），2000 代表年，0 代表月（1 月）。因为没有其他参数（日取 1，其他取 0），所以结果就是该月第 1 天零点。第二个日期表示 2005 年 5 月 5 日下午 5 点 55 分 55 秒（GMT）。虽然日期里面涉及的都是 5，但月数必须用 4，因为月数是零起点的。小时也必须是 17，因为这里采用的是 24 小时制，即取值范围是 0~23。其他参数就都很直观了。

与 Date.parse()一样，Date.UTC()也会被 Date 构造函数隐式调用，但有一个区别：这种情况下创建的是本地日期，不是 GMT 日期。不过 Date 构造函数跟 Date.UTC()接收的参数是一样的。因此，如果第一个参数是数值，则构造函数假设它是日期中的年，第二个参数就是月，以此类推。前面的例子也可以这样来写：

```js
// 本地时间2000 年1 月1 日零点
let y2k = new Date(2000, 0);

// 本地时间2005 年5 月5 日下午5 点55 分55 秒
let allFives = new Date(2005, 4, 5, 17, 55, 55);
```

以上代码创建了与前面例子中相同的两个日期，但这次的两个日期是（由于系统设置决定的）本地时区的日期。

ECMAScript 还提供了 Date.now()方法，返回表示方法执行时日期和时间的毫秒数。这个方法可以方便地用在代码分析中：

```js
// 起始时间
let start = Date.now();

// 调用函数
doSomething();

// 结束时间
let stop = Date.now(),
  result = stop - start;
```

### 5.1.1. 继承的方法

与其他类型一样，Date 类型重写了 toLocaleString()、toString()和 valueOf()方法。但与其他类型不同，重写后这些方法的返回值不一样。Date 类型的 toLocaleString()方法返回与浏览器运行的本地环境一致的日期和时间。这通常意味着格式中包含针对时间的 AM（上午）或 PM（下午），但不包含时区信息（具体格式可能因浏览器而不同）。toString()方法通常返回带时区信息的日期和时间，而时间也是以 24 小时制（0~23）表示的。下面给出了 toLocaleString()和 toString()返回的 2019 年 2 月 1 日零点的示例（地区为"en-US"的 PST，即 Pacific Standard Time，太平洋标准时间）：

toLocaleString() - 2/1/2019 12:00:00 AM
toString() - Thu Feb 1 2019 00:00:00 GMT-0800 (Pacific Standard Time)

现代浏览器在这两个方法的输出上已经趋于一致。在比较老的浏览器上，每个方法返回的结果可能在每个浏览器上都是不同的。这些差异意味着 toLocaleString()和 toString()可能只对调试有用，不能用于显示。

Date 类型的 valueOf()方法根本就不返回字符串，这个方法被重写后返回的是日期的毫秒表示。因此，操作符（如小于号和大于号）可以直接使用它返回的值。比如下面的例子：

```js
let date1 = new Date(2019, 0, 1); // 2019 年1 月1 日
let date2 = new Date(2019, 1, 1); // 2019 年2 月1 日

console.log(date1 < date2); // true
console.log(date1 > date2); // false
```

日期 2019 年 1 月 1 日在 2019 年 2 月 1 日之前，所以说前者小于后者没问题。因为 2019 年 1 月 1 日的毫秒表示小于 2019 年 2 月 1 日的毫秒表示，所以用小于号比较这两个日期时会返回 true。这也是确保日期先后的一个简单方式。

### 5.1.2. 日期格式化方法

Date 类型有几个专门用于格式化日期的方法，它们都会返回字符串：

- toDateString()显示日期中的周几、月、日、年（格式特定于实现）；
- toTimeString()显示日期中的时、分、秒和时区（格式特定于实现）；
- toLocaleDateString()显示日期中的周几、月、日、年（格式特定于实现和地区）；
- toLocaleTimeString()显示日期中的时、分、秒（格式特定于实现和地区）；
- toUTCString()显示完整的 UTC 日期（格式特定于实现）。

这些方法的输出与 toLocaleString()和 toString()一样，会因浏览器而异。因此不能用于在用户界面上一致地显示日期。

注意 还有一个方法叫 toGMTString()，这个方法跟 toUTCString()是一样的，目的是为了向后兼容。不过，规范建议新代码使用 toUTCString()。

### 5.1.3. 日期/时间组件方法

Date 类型剩下的方法（见下表）直接涉及取得或设置日期值的特定部分。注意表中“UTC 日期”，指的是没有时区偏移（将日期转换为 GMT）时的日期。

| 方 法                                       | 说 明                                                                                                      |
| ------------------------------------------- | ---------------------------------------------------------------------------------------------------------- |
| getTime()                                   | 返回日期的毫秒表示；与 valueOf()相同                                                                       |
| setTime(milliseconds)                       | 设置日期的毫秒表示，从而修改整个日期                                                                       |
| getFullYear()                               | 返回 4 位数年（即 2019 而不是 19）                                                                         |
| getUTCFullYear()                            | 返回 UTC 日期的 4 位数年                                                                                   |
| setFullYear(year)                           | 设置日期的年（year 必须是 4 位数）                                                                         |
| setUTCFullYear(year)                        | 设置 UTC 日期的年（year 必须是 4 位数）                                                                    |
| getMonth()                                  | 返回日期的月（0 表示 1 月，11 表示 12 月）                                                                 |
| getUTCMonth()                               | 返回 UTC 日期的月（0 表示 1 月，11 表示 12 月）                                                            |
| setMonth(month)                             | 设置日期的月（month 为大于 0 的数值，大于 11 加年）                                                        |
| setUTCMonth(month)                          | 设置 UTC 日期的月（month 为大于 0 的数值，大于 11 加年）                                                   |
| getDate()                                   | 返回日期中的日（1~31）                                                                                     |
| getUTCDate()                                | 返回 UTC 日期中的日（1~31）                                                                                |
| setDate(date)                               | 设置日期中的日（如果 date 大于该月天数，则加月）                                                           |
| setUTCDate(date)                            | 设置 UTC 日期中的日（如果 date 大于该月天数，则加月）                                                      |
| getDay()                                    | 返回日期中表示周几的数值（0 表示周日，6 表示周六）                                                         |
| getUTCDay()                                 | 返回 UTC 日期中表示周几的数值（0 表示周日，6 表示周六）                                                    |
| getHours() 返回日期中的时（0~23）           |
| getUTCHours()                               | 返回 UTC 日期中的时（0~23）                                                                                |
| setHours(hours)                             | 设置日期中的时（如果 hours 大于 23，则加日）                                                               |
| setUTCHours(hours)                          | 设置 UTC 日期中的时（如果 hours 大于 23，则加日）                                                          |
| getMinutes()                                | 返回日期中的分（0~59）                                                                                     |
| getUTCMinutes() 返回 UTC 日期中的分（0~59） |
| setMinutes(minutes)                         | 设置日期中的分（如果 minutes 大于 59，则加时）                                                             |
| setUTCMinutes(minutes)                      | 设置 UTC 日期中的分（如果 minutes 大于 59，则加时）                                                        |
| getSeconds()                                | 返回日期中的秒（0~59）                                                                                     |
| getUTCSeconds()                             | 返回 UTC 日期中的秒（0~59）                                                                                |
| setSeconds(seconds)                         | 设置日期中的秒（如果 seconds 大于 59，则加分）                                                             |
| setUTCSeconds(seconds)                      | 设置 UTC 日期中的秒（如果 seconds 大于 59，则加分）                                                        |
| getMilliseconds()                           | 返回日期中的毫秒                                                                                           |
| getUTCMilliseconds()                        | 返回 UTC 日期中的毫秒                                                                                      |
| setMilliseconds(milliseconds)               | 设置日期中的毫秒                                                                                           |
| setUTCMilliseconds(milliseconds)            | 设置 UTC 日期中的毫秒                                                                                      |
| getTimezoneOffset()                         | 返回以分钟计的 UTC 与本地时区的偏移量（如美国 EST 即“东部标准时间”返回 300，进入夏令时的地区可能有所差异） |

下面是一个演示：

```js
function getTime(date) {
  return `${date.getFullYear()}-${
    date.getMonth() + 1
  }-${date.getDate()} ${date.getHours()}:${date.getMinutes()}:${date.getSeconds()} ${date.getMilliseconds()}ms`;
}
console.log(getTime(new Date())); // 2021-8-7 17:55:40 837ms
```

## 5.2. RegExp

ECMAScript 通过 RegExp 类型支持正则表达式。正则表达式使用类似 Perl 的简洁语法来创建：

```js
let expression = /pattern/flags;
```

这个正则表达式的 pattern（模式）可以是任何简单或复杂的正则表达式，包括字符类、限定符、分组、向前查找和反向引用。每个正则表达式可以带零个或多个 flags（标记），用于控制正则表达式的行为。下面给出了表示匹配模式的标记。

- g：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。
- i：不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写。
- m：多行模式，表示查找到一行文本末尾时会继续查找。
- y：粘附模式，表示只查找从 lastIndex 开始及之后的字符串。
- u：Unicode 模式，启用 Unicode 匹配。
- s：dotAll 模式，表示元字符.匹配任何字符（包括\n 或\r）。

使用不同模式和标记可以创建出各种正则表达式，比如：

```js
// 匹配字符串中的所有"at"
let pattern1 = /at/g;

// 匹配第一个"bat"或"cat"，忽略大小写
let pattern2 = /[bc]at/i;

// 匹配所有以"at"结尾的三字符组合，忽略大小写
let pattern3 = /.at/gi;
```

与其他语言中的正则表达式类似，所有元字符在模式中也必须转义，包括：

( [ { \ ^ $ | ) ] } ? \* + .

元字符在正则表达式中都有一种或多种特殊功能，所以要匹配上面这些字符本身，就必须使用反斜杠来转义。下面是几个例子：

```js
// 匹配第一个"bat"或"cat"，忽略大小写
let pattern1 = /[bc]at/i;

// 匹配第一个"[bc]at"，忽略大小写
let pattern2 = /\[bc\]at/i;

// 匹配所有以"at"结尾的三字符组合，忽略大小写
let pattern3 = /.at/gi;

// 匹配所有".at"，忽略大小写
let pattern4 = /\.at/gi;
```

这里的 pattern1 匹配"bat"或"cat"，不区分大小写。要直接匹配"\[bc\]at"，左右中括号都必须像 pattern2 中那样使用反斜杠转义。在 pattern3 中，点号表示"at"前面的任意字符都可以匹配。如果想匹配".at"，那么要像 pattern4 中那样对点号进行转义。

前面例子中的正则表达式都是使用字面量形式定义的。正则表达式也可以使用 RegExp 构造函数来创建，它接收两个参数：模式字符串和（可选的）标记字符串。任何使用字面量定义的正则表达式也可以通过构造函数来创建，比如：

```js
// 匹配第一个"bat"或"cat"，忽略大小写
let pattern1 = /[bc]at/i;

// 跟pattern1 一样，只不过是用构造函数创建的
let pattern2 = new RegExp("[bc]at", "i");
```

这里的 pattern1 和 pattern2 是等效的正则表达式。注意，RegExp 构造函数的两个参数都是字符串。因为 RegExp 的模式参数是字符串，所以在某些情况下需要二次转义。所有元字符都必须二次转义，包括转义字符序列，如\n（\转义后的字符串是\\，在正则表达式字符串中则要写成\\\\）。下表展示了几个正则表达式的字面量形式，以及使用 RegExp 构造函数创建时对应的模式字符串。

| 字面量模式         | 对应的字符串            |
| ------------------ | ----------------------- |
| `/\[bc\]at/`       | `"\\[bc\\]at"`          |
| `/\.at/ `          | `"\\.at"`               |
| `/name\/age/`      | `"name\\/age"`          |
| `/\d.\d{1,2}/`     | `"\\d.\\d{1,2}"`        |
| `/\w\\hello\\123/` | `"\\w\\\\hello\\\\123"` |

此外，使用RegExp 也可以基于已有的正则表达式实例，并可选择性地修改它们的标记：

```js
const re1 = /cat/g;
console.log(re1); // "/cat/g"

const re2 = new RegExp(re1);
console.log(re2); // "/cat/g"

const re3 = new RegExp(re1, "i");
console.log(re3); // "/cat/i"
```

### 5.2.1. RegExp 实例属性

每个RegExp 实例都有下列属性，提供有关模式的各方面信息。

- global：布尔值，表示是否设置了g 标记。
- ignoreCase：布尔值，表示是否设置了i 标记。
- unicode：布尔值，表示是否设置了u 标记。
- sticky：布尔值，表示是否设置了y 标记。
- lastIndex：整数，表示在源字符串中下一次搜索的开始位置，始终从0 开始。
- multiline：布尔值，表示是否设置了m 标记。
- dotAll：布尔值，表示是否设置了s 标记。
- source：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。
- flags：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）。

通过这些属性可以全面了解正则表达式的信息，不过实际开发中用得并不多，因为模式声明中包含这些信息。下面是一个例子：

```js
let pattern1 = /\[bc\]at/i;

console.log(pattern1.global); // false
console.log(pattern1.ignoreCase); // true
console.log(pattern1.multiline); // false
console.log(pattern1.lastIndex); // 0
console.log(pattern1.source); // "\[bc\]at"
console.log(pattern1.flags); // "i"

let pattern2 = new RegExp("\\[bc\\]at", "i");

console.log(pattern2.global); // false
console.log(pattern2.ignoreCase); // true
console.log(pattern2.multiline); // false
console.log(pattern2.lastIndex); // 0
console.log(pattern2.source); // "\[bc\]at"
console.log(pattern2.flags); // "i"
```

注意，虽然第一个模式是通过字面量创建的，第二个模式是通过RegExp 构造函数创建的，但两个模式的source 和flags 属性是相同的。source 和flags 属性返回的是规范化之后可以在字面量中使用的形式。

### 5.2.2. RegExp 实例方法

RegExp 实例的主要方法是exec()，主要用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，则返回包含第一个匹配信息的数组；如果没找到匹配项，则返回null。返回的数组虽然是Array 的实例，但包含两个额外的属性：index 和input。index 是字符串中匹配模式的起始位置，input 是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串。如果模式中没有捕获组，则数组只包含一个元素。来看下面的例子：

```js
let text = "mom and dad and baby";
let pattern = /mom( and dad( and baby)?)?/gi;

let matches = pattern.exec(text);
console.log(matches.index); // 0
console.log(matches.input); // "mom and dad and baby"
console.log(matches[0]); // "mom and dad and baby"
console.log(matches[1]); // " and dad and baby"
console.log(matches[2]); // " and baby"
```

在这个例子中，模式包含两个捕获组：最内部的匹配项" and baby"，以及外部的匹配项" and dad"或" and dad and baby"。调用exec()后找到了一个匹配项。因为整个字符串匹配模式，所以matchs数组的index 属性就是0。数组的第一个元素是匹配的整个字符串，第二个元素是匹配第一个捕获组的字符串，第三个元素是匹配第二个捕获组的字符串。

如果模式设置了全局标记，则每次调用exec()方法会返回一个匹配的信息。如果没有设置全局标记，则无论对同一个字符串调用多少次exec()，也只会返回第一个匹配的信息。

```js
let text = "cat, bat, sat, fat";
let pattern = /.at/;

let matches = pattern.exec(text);
console.log(matches.index); // 0
console.log(matches[0]); // cat
console.log(pattern.lastIndex); // 0

matches = pattern.exec(text);
console.log(matches.index); // 0
console.log(matches[0]); // cat
console.log(pattern.lastIndex); // 0
```

